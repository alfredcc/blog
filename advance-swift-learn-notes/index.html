<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="Race Chao" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="Race Chao" /> <title> Advanced Swift 学习笔记 - Race Chao </title> <link rel="alternate" href="https://jiechaoz.com/advance-swift-learn-notes/" hreflang="en-US" /> <link rel="canonical" href="https://jiechaoz.com/advance-swift-learn-notes/" /> <meta name="description" content="欢迎来到我的小小站点， 不定期给大家分享一些开发的小知识 @github." /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Advanced Swift 学习笔记 | alfredcc" /> <meta property="og:title" content="Advanced Swift 学习笔记 | alfredcc" /> <meta property="og:type" content="website" /> <meta property="og:url" content="https://jiechaoz.com/advance-swift-learn-notes/" /> <meta property="og:description" content="欢迎来到我的小小站点， 不定期给大家分享一些开发的小知识 @github." /> <meta property="og:image" content="https://jiechaoz.com/assets/img/ogp.png" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Advanced Swift 学习笔记 | alfredcc" /> <meta name="twitter:url" content="https://jiechaoz.com/advance-swift-learn-notes/" /> <meta name="twitter:site" content="@alfredcc" /> <meta name="twitter:creator" content="@alfredcc" /> <meta name="twitter:description" content="欢迎来到我的小小站点， 不定期给大家分享一些开发的小知识 @github." /> <meta name="twitter:image" content="https://jiechaoz.com/assets/img/ogp.png" /> <link type="application/atom+xml" rel="alternate" href="https://jiechaoz.com/feed.xml" title="Race Chao" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark"> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="https://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="https://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"> <a class="menu-link" href="/">Archive</a> <a class="menu-link" href="/notes/">Notes</a> <a class="menu-link" href="/about/">About</a> <a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <div class="tags"> <span itemprop="keywords"> <a class="tag" href="/tags/#swift">SWIFT</a> </span> </div> <h1 class="header-title" itemprop="headline">Advanced Swift 学习笔记</h1> <div class="post-meta"> <time datetime="2020-11-16T00:00:00+00:00" itemprop="datePublished"> Nov 16, 2020 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">racechao</span> </span> <time hidden datetime="" itemprop="dateModified"> Nov 16, 2020 </time> <span hidden itemprop="publisher" itemtype="Person">racechao</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><p>一个优秀的程序员往往对技术层面的边界非常清楚，对这些边界的认知可以让我们知道什么技术用来解决什么问题。</p> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <p>一个优秀的程序员往往对技术层面的边界非常清楚，对这些边界的认知可以让我们知道什么技术用来解决什么问题。</p> <p>在学习语言的过程中也是一样，只有清楚认识到各种语法以及编程语言语意上的不同之处及边界，才能让我们写出更好的代码。学习《Advanced Swift》这本书，希望可以提升自己对 swift 这门语言在这方面的认知，写出更好的代码。在读书的时候，虽然当我们遇到新的知识点会豁然开朗的感觉，但随着时间的流逝很多当时觉得耳目一新的知识点往往会被忘记，只有反复阅读才能慢慢吸收变成自己的知识。这也是我记录笔记的原因。</p> <blockquote> <p>如果文章内容有侵权的地方，请联系我</p> </blockquote> <h2 id="if-let"> <a href="#if-let" class="anchor-head"></a> if let </h2> <p>if let 解包的一个 value type 的时候要注意解包后的值只是一份copy，改变的时候不影响原来的值</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">originInt</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">if</span> <span class="k">var</span> <span class="nv">new</span> <span class="o">=</span> <span class="n">originInt</span> <span class="p">{</span>
    <span class="k">new</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// 3</span>
<span class="p">}</span>

<span class="n">originInt</span>   <span class="c1">// 2</span>
</code></pre></div></div> <h2 id="flatmap-展平操作"> <a href="#flatmap-展平操作" class="anchor-head"></a> flatMap 展平操作 </h2> <p>flatMap 可以把结果展平为单个可选值</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">flatMap</span><span class="p">{</span> <span class="kt">Int</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// Optional(1)</span>
<span class="c1">// 等价于</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"3"</span><span class="p">]</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="kt">Int</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="隐式可选值行为"> <a href="#隐式可选值行为" class="anchor-head"></a> 隐式可选值行为 </h2> <p>在 iOS 编程的世界中我们经常会看到 <code class="language-plaintext highlighter-rouge">@IBOutlet var contentView: UIView!</code> 这样的代码，这是因为 ViewController 会延迟创建 view。这里有两个阶段:</p> <ol> <li>创建 ViewController 自身</li> <li>加载 outlet view。在这两个阶段之间 outlet 引用还未被创建。</li> </ol> <p>另外一个场景：因为我们的代码有时候会桥接 OC/C 的方法，OC 方法很久以前还没有引入可选值，但我们都知道 OC 的对象其实是一个引用（ptr指针），有时候这个引用会返回空。但大多数情况下都是有值的，所以为了书写方便就实现了隐式隐式可选值。</p> <h2 id="闭包的定义"> <a href="#闭包的定义" class="anchor-head"></a> 闭包的定义 </h2> <blockquote> <p>“在编程术语里，一个函数和它所捕获的变量环境组合起来被称为闭包”</p> </blockquote> <h2 id="inout"> <a href="#inout" class="anchor-head"></a> inout </h2> <ol> <li>inout 在 Swift 中其实不是引用传递，而是值传递，在函数结束的时候把新值 copy 回去。 <blockquote> <p>“一个 inout 参数持有一个传递给函数的值，函数可以改变这个值，然后从函数中传出并替换掉原来的值。”</p> </blockquote> </li> <li>在闭包中不能让 inout 参数逃离（原因如上）</li> </ol> <h2 id="autoclosure"> <a href="#autoclosure" class="anchor-head"></a> autoclosure </h2> <p>在编程语言中 &amp;&amp; 操作符的右边是延迟执行的，只有左边满足条件才会调用右边。因为 swift 函数是一等公民，我们可以用闭包（匿名函数）来实现这个“延迟执行”的功能，如下：</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">and</span><span class="p">(</span><span class="n">_</span> <span class="nv">l</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="n">_</span> <span class="nv">r</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
  <span class="k">guard</span> <span class="n">l</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
  <span class="k">return</span> <span class="nf">r</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>但是在调用的时候就比较麻烦，需要在调用参数上加”{}”，比较好的是 swfit 加入了 <code class="language-plaintext highlighter-rouge">@autoclosure</code> 的语法糖，使得我们可以省略{}的写法。另外因为 closure 延迟的特性，我们的“参数方法”不一定会被执行到，我们应当谨慎使用。</p> <h2 id="struct"> <a href="#struct" class="anchor-head"></a> struct </h2> <p>struct 相比 class 更加轻量，没有继承，不能共享内存，也没有引用计数，但 struct 副作用很小，我们不用担心循环引用的问题，这样我们使得我们的程序更容易维护。 当 struct 内部持有一个引用类型：这个时候这个 struct 赋值的时候，他内部这个引用类型的属性并不会完全拷贝一份，而仅仅只是复制了指针，此时的 struct 并不是完全意义上的 <code class="language-plaintext highlighter-rouge">value type</code>。</p> <h2 id="写时复制"> <a href="#写时复制" class="anchor-head"></a> 写时复制 </h2> <p>我们都知道值类型在 swift 往往具有写时复制的特性，但不是所有值类型都具有“写时复制”的特性，在 swift 中大多数值类型都具有这个特性，那是因为 Foundation 帮我们实现来这个功能。但为了实现“写时复制”这个功能我们会依赖内部的一个引用计数，维护这份引用计数并不是那么“轻量”，因为我们要保证这个引用计数的线程安全，不能避免锁的开销（Swift 已经有 Atomic 相关的提案了，不知道未来是不是可以通过这个特性来优化）。</p> <p>copy on write 内部实现是用了一个 private 的 class 来存储这个值类型的变量，然后通过变量 get set 的方式将内部class 的属性暴露出去。在 set 方法中调用 <code class="language-plaintext highlighter-rouge">copy()</code> 来实现 copy on write。要注意的时候我们需要检查内部这个 class 的 storage 的引用是不是唯一的，因为如果是同一个引用，我们没必要在每次修改的时候都进行复制操作，那是一种资源的浪费。</p> <h2 id="indirect"> <a href="#indirect" class="anchor-head"></a> indirect </h2> <p><img src="/assets/img/struct-recursively.png" alt="img" /> 我们在用 <code class="language-plaintext highlighter-rouge">struct</code> 的时候如果属性包含了自己，会遇到 <code class="language-plaintext highlighter-rouge">Value type 'A' cannot have a stored property that recursively contains it</code> 的错误。那是因为编译器对于值类型需要能够计算他内存布局的大小，这个大小是一个固定的有限的尺寸。假设我们可以包含自身，那就可能出现无限递归，编译器就不能确定大小了。</p> <p>在枚举中我们可以用 <code class="language-plaintext highlighter-rouge">indirect</code> 修饰，但仅适用于枚举。<code class="language-plaintext highlighter-rouge">indirect</code> 可以用来告诉编译器将我们递归的成员作为一个引用（因为引用的大小是确定的，在64位的系统上是 8 个字节）。</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 类似实现</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">Box</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">unbox</span><span class="p">:</span> <span class="kt">A</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="p">{</span><span class="k">self</span><span class="o">.</span><span class="n">unbox</span> <span class="o">=</span> <span class="n">value</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="existential"> <a href="#existential" class="anchor-head"></a> existential </h2> <p>一般来讲在 Swift 中我们不能把协议作为一个具体的类型，他们只能用来当作约束范型.</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 编译器会帮为协议生成一个 container：existential container</span>
<span class="c1">// 下面代码类似：let type: Any&lt;SomeProtocol&gt;</span>
<span class="k">let</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">SomeProtocol</span>
</code></pre></div></div> <h2 id="protocol-和-generic"> <a href="#protocol-和-generic" class="anchor-head"></a> protocol 和 generic </h2> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">encode1</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Encodable</span><span class="p">)</span> <span class="p">{}</span>
<span class="kd">func</span> <span class="n">encode2</span><span class="o">&lt;</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Encodable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">E</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div> <p>这两个函数看起都是传入了一个 <code class="language-plaintext highlighter-rouge">Encodable</code> 的参数。但它们不同但是对于 encode1 函数编译器会把参数放到一个 existential container 容器中，会带来一定开销。 而对于范型函数编译器会为参数生成一个特定的版本，性能和我们手动重载这个函数差不多。但缺点是会带来更长但编译时间和更大二进制程序。不过大多数情况下，我们可以忽略 existential contarner 带来但性能差异。</p> <h2 id="类型消除器type-erasure-和-opaque-return"> <a href="#类型消除器type-erasure-和-opaque-return" class="anchor-head"></a> 类型消除器(type erasure) 和 Opaque Return </h2> <p>这两者适合结合起来学习，相关的资料有很多，内容很多到时候可以另开一篇文章讲讲。 talks:</p> <ul> <li><a href="https://academy.realm.io/posts/tryswift-gwendolyn-weston-type-erasure/">Keep Calm and Type Erase On - Gwendolyn Weston</a></li> <li><a href="https://www.youtube.com/watch?v=XWoNjiSPqI8">Protocols with Associated Types - Alexis Gallagher</a> articles:</li> <li><a href="https://www.alfianlosari.com/posts/understanding-opaque-return-type/">Understanding Opaque Return Types in Swift</a></li> </ul> <h2 id="序列"> <a href="#序列" class="anchor-head"></a> 序列 </h2> <p>一个序列(Sequence)代表一组相同类型的值，满足 Sequence 协议的类型我们可以对其进行 for 循环等遍历操作。</p> <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Sequence</span> <span class="p">{</span>
    <span class="c1">/// A type representing the sequence's elements.</span>
    <span class="kd">associatedtype</span> <span class="kt">Element</span> <span class="k">where</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span>
    <span class="c1">/// A type that provides the sequence's iteration interface and</span>
    <span class="c1">/// encapsulates its iteration state.</span>
    <span class="kd">associatedtype</span> <span class="kt">Iterator</span> <span class="p">:</span> <span class="kt">IteratorProtocol</span>
    <span class="c1">/// Returns an iterator over the elements of this sequence.</span>
    <span class="kd">func</span> <span class="nf">makeIterator</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span><span class="o">.</span><span class="kt">Iterator</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="编码和解码"> <a href="#编码和解码" class="anchor-head"></a> 编码和解码 </h2> <p>我们都知道标准库的很多基本类型都已经实现了 <code class="language-plaintext highlighter-rouge">Codable</code> ( Codable 是 Decodable 和 Encodebale 的 组合)。如果要让一个类或者结构体实现 <code class="language-plaintext highlighter-rouge">Codable</code> 我们只要保证他们内部的数据都分别实现 <code class="language-plaintext highlighter-rouge">Codable</code> 即可。这部分工作是编译器帮我实现的，他和标准库的默认实现不一样。假设我们要把这部分指责迁移到标准库中，这就需要 Swift 具有强大的反射能力（类似 OC 的一些运行时的能力，但这样做往往会产生一些而外的开销）。另外 Swift 很多其他语言特效都是这样做的，比如自动实现的 <code class="language-plaintext highlighter-rouge">Equatable</code> 和 <code class="language-plaintext highlighter-rouge">Hashable</code> 这也是编译 Swift 比 OC 慢很多的主要原因。</p> <blockquote> <p>Tips: Swift 目前不能在类型定义之外自动合成实现 <code class="language-plaintext highlighter-rouge">Encodable</code>, 也就是说不能通过 extension 实现 Encodable。（要让 Swift 自动合成协议实现代码需要在将协议添加在类型定义的地方或者加载同文件下的 extension 中）</p> </blockquote> <p>在这里苹果工程师的建议是：<em>当你想要扩展别人的类型使其满足 <code class="language-plaintext highlighter-rouge">Encodable</code> 或者 <code class="language-plaintext highlighter-rouge">Decodable</code> 时，我们应该靠考虑用一个结构体封装起来，除非我们确定这个类型以后自己不会遵循这些协议。</em>$$</p> </div> </article> <!-- unnecessary file, but you can still use for comment section, e.g disqus --> <script src="https://utteranc.es/client.js" repo="alfredcc/blog" issue-term="pathname" label="✨ comment ✨" theme="photon-dark" crossorigin="anonymous" async ></script> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/memberwise-initializer/" > <div class="nav-arrow">Previous</div> <span class="post-title">Swift 中关于 Memberwise Initializer 的一个小技巧</span> </a> </nav> <footer class="footer"> <!-- <a class="footer_item" href="/thanks">ack.</a> --> <a class="footer_item" href="/resume">resume</a> <a class="footer_item" href="/feed.xml">rss</a> <small class="footer_theme-copyright"> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > <span class="footer_item">&copy; 2020</span> </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> <script src="/assets/js/galite.js"></script> <script> var galite = galite || {}; galite.UA = "UA-154766060-1"; </script> </div> </body> </html>
