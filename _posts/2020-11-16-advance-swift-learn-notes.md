---
title: Advanced Swift 学习笔记
author: racechao
date: 2020-11-16
tag:
  - swift
---

一个优秀的程序员往往对技术层面的边界非常清楚，对这些边界的认知可以让我们知道什么技术用来解决什么问题。

在学习语言的过程中也是一样，只有清楚认识到各种语法以及编程语言语意上的不同之处及边界，才能让我们写出更好的代码。学习《Advanced Swift》这本书，希望可以提升自己对 swift 这门语言在这方面的认知，写出更好的代码。在读书的时候，虽然当我们遇到新的知识点会豁然开朗的感觉，但随着时间的流逝很多当时觉得耳目一新的知识点往往会被忘记，只有反复阅读才能慢慢吸收变成自己的知识。这也是我记录笔记的原因。

> 如果文章内容有侵权的地方，请联系我

## if let
if let 解包的一个 value type 的时候要注意解包后的值只是一份copy，改变的时候不影响原来的值
```swift
let originInt: Int? = 2
if var new = originInt {
    new += 1 // 3
}

originInt   // 2
```

## flatMap 展平操作
flatMap 可以把结果展平为单个可选值
```swift
let value = ["1","2","3"].first.flatMap{ Int($0) } // Optional(1)
// 等价于
if let first = ["1","2","3"].first, let value = Int(first) {
    print(value) // 1
}
```

## 隐式可选值行为
在 iOS 编程的世界中我们经常会看到 `@IBOutlet var contentView: UIView!` 这样的代码，这是因为 ViewController 会延迟创建 view。这里有两个阶段:
 1. 创建 ViewController 自身 
 2. 加载 outlet view。在这两个阶段之间 outlet 引用还未被创建。

另外一个场景：因为我们的代码有时候会桥接 OC/C 的方法，OC 方法很久以前还没有引入可选值，但我们都知道 OC 的对象其实是一个引用（ptr指针），有时候这个引用会返回空。但大多数情况下都是有值的，所以为了书写方便就实现了隐式隐式可选值。

## 闭包的定义
> “在编程术语里，一个函数和它所捕获的变量环境组合起来被称为闭包”

## inout
1. inout 在 Swift 中其实不是引用传递，而是值传递，在函数结束的时候把新值 copy 回去。
> “一个 inout 参数持有一个传递给函数的值，函数可以改变这个值，然后从函数中传出并替换掉原来的值。”

1. 在闭包中不能让 inout 参数逃离（原因如上）

## autoclosure
在编程语言中 && 操作符的右边是延迟执行的，只有左边满足条件才会调用右边。因为 swift 函数是一等公民，我们可以用闭包（匿名函数）来实现这个“延迟执行”的功能，如下：
```swift
func and(_ l: Bool, _ r: () -> Bool) -> Bool {
  guard l else { return false }
  return r()
}
```
但是在调用的时候就比较麻烦，需要在调用参数上加"{}"，比较好的是 swfit 加入了 `@autoclosure` 的语法糖，使得我们可以省略{}的写法。另外因为 closure 延迟的特性，我们的“参数方法”不一定会被执行到，我们应当谨慎使用。

## struct 
struct 相比 class 更加轻量，没有继承，不能共享内存，也没有引用计数，但 struct 副作用很小，我们不用担心循环引用的问题，这样我们使得我们的程序更容易维护。
当 struct 内部持有一个引用类型：这个时候这个 struct 赋值的时候，他内部这个引用类型的属性并不会完全拷贝一份，而仅仅只是复制了指针，此时的 struct 并不是完全意义上的 `value type`。

## 写时复制
我们都知道值类型在 swift 往往具有写时复制的特性，但不是所有值类型都具有“写时复制”的特性，在 swift 中大多数值类型都具有这个特性，那是因为 Foundation 帮我们实现来这个功能。但为了实现“写时复制”这个功能我们会依赖内部的一个引用计数，维护这份引用计数并不是那么“轻量”，因为我们要保证这个引用计数的线程安全，不能避免锁的开销（Swift 已经有 Atomic 相关的提案了，不知道未来是不是可以通过这个特性来优化）。

copy on write 内部实现是用了一个 private 的 class 来存储这个值类型的变量，然后通过变量 get set 的方式将内部class 的属性暴露出去。在 set 方法中调用 `copy()` 来实现 copy on write。要注意的时候我们需要检查内部这个 class 的 storage 的引用是不是唯一的，因为如果是同一个引用，我们没必要在每次修改的时候都进行复制操作，那是一种资源的浪费。

## indirect
`indirect` 语法仅适用于枚举。因为枚举是值类型，值类型是不能包含自身的，因为编译器需要能够计算每种类型的大小，这个大小是一个固定的有限的尺寸。假设我们可以包含自身，那就可能出现无限递归，编译器就不能确定大小了，所以 `indirect` 可以用来告诉编译器将我们递归的成员作为一个引用（因为引用的大小是确定的，在64位的系统上是 8 个字节）。
```swift
// 类似实现
final class Box<A> {
  var unbox: A
  init(_ value: A) {self.unbox = valeu }
}
```
